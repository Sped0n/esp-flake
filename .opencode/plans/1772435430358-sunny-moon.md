# Plan: Clean `flake.nix` devShells (ESP-IDF + Matter on NixOS)

## Goal

- Move most environment variables (notably `NIX_LD`, `NIX_LD_LIBRARY_PATH`, and ccache-related vars) into `pkgs.mkShell*` attributes instead of `shellHook`.
- Do not export `LD_LIBRARY_PATH` at all.
- Refactor the ESP-IDF clone/install/export workflow to be KISS (no implicit side effects on shell entry; drop or strongly simplify `idfEnsure`/`idfAutoInstall`).
- Keep multi-system support (`x86_64-linux`, `aarch64-linux`).

## Non-goals / Constraints

- No wrapper-based workflow (no patchelf, no per-tool wrappers as the primary path).
- Keep the shell usable for ESP-IDF + Matter builds on NixOS.
- Assume system `nix-ld` interpreter shim exists (foreign binaries require `/lib64/ld-linux-*.so.*`).

## Proposed UX (recommended)

- Entering `nix develop .#idf_vX_Y_Z`:
  - Sets `NIX_LD` and `NIX_LD_LIBRARY_PATH` declaratively (mkShell attrs).
  - Does **not** touch `LD_LIBRARY_PATH`.
  - Does **not** auto-clone ESP-IDF and does **not** auto-run `install.sh`.
  - If `IDF_PATH` points to a valid ESP-IDF checkout, source `$IDF_PATH/export.sh`.
  - Otherwise, print a short hint and continue (so you can run setup commands in the same shell).

- Provide one explicit helper command (user-invoked):
  - `idf-sync`: creates/updates the ESP-IDF checkout for the shell's tag and then (re)runs tool installation into `$IDF_TOOLS_PATH`.

This keeps the flake clean and predictable: `shellHook` only performs lightweight checks/activation.

### First-time flow (expected)

On a fresh machine (no ESP-IDF checkout yet):

1) `nix develop .#idf_vX_Y_Z` (prints hint; does not fail)
2) `idf-sync` (creates/updates the checkout at the default location, then runs `install.sh`)
3) Either `source "$IDF_PATH/export.sh"` in the same shell, or re-enter the devshell.

On an existing environment:

- Re-running `idf-sync` fetches/updates the checkout and runs `install.sh` again (the default is “refresh”, not “skip if marker exists”).

## Design Details

### A) Environment variables moved into `mkShell`

In `flake.nix`, set these directly on the shell derivation:

- `NIX_LD = lib.fileContents "${pkgs.stdenv.cc}/nix-support/dynamic-linker";`
- `NIX_LD_LIBRARY_PATH = lib.makeLibraryPath nixLdRuntimeLibs;`
- `IDF_CCACHE_ENABLE = "1";`
- `CCACHE_NOHASHDIR = "1";`
- `CCACHE_SLOPPINESS = "locale,time_macros,random_seed";`

Notes:

- Drop `LD_LIBRARY_PATH` entirely.
- Prefer removing `GI_TYPELIB_PATH` export as well (keep the environment clean; re-add later only if a concrete need appears).

### B) Runtime libraries and path variables

- Keep `runtimeLibs` list as the single source of truth.
- Keep only `nixLdRuntimeLibs = [ pkgs.glibc ] ++ runtimeLibs;`.
- Remove `ldRuntimeLibs` (it becomes unused once `LD_LIBRARY_PATH` is removed).

### C) KISS ESP-IDF workflow

Refactor `mkIdfShell`:

1) Remove implicit side effects on entry:

- Remove `idfEnsure` and `idfAutoInstall` from `packages`.
- Remove calls to `idf-ensure` and `idf-auto-install` from `shellHook`.

2) Keep activation minimal:

- `shellHook` behavior:
  - If `IDF_PATH` is set and `$IDF_PATH/export.sh` exists, source it.
  - Else if `IDF_PATH` is unset, set a *default* value based on `$HOME` and the tag (e.g. `$HOME/.local/share/esp-idf-${tag}`) and attempt to source it if present.
  - If export script is missing, print one concise hint (no hard failure).

3) Provide explicit helpers (user-triggered) instead of auto-run:

- Replace `idfEnsure` + `idfAutoInstall` with one helper script:
  - `idf-sync`: clone/fetch or update worktree for the shell's tag into the default location, then run tool installation.

4) Keep defaults but allow override:

- Keep default `IDF_TOOLS_PATH` in `shellHook` (because `$HOME` must be expanded at runtime):
  - If unset: `IDF_TOOLS_PATH="$HOME/.local/share/esp-idf-tools"`.

Rationale:

- Home-based paths cannot be expressed purely as mkShell env attrs (Nix does not expand `$HOME` in attr values).
- Making setup explicit avoids surprising network writes during `nix develop`.

## File(s) to change

- `flake.nix`
  - `mkIdfShell` (scripts + shellHook)
  - env var placement (mkShell attrs)
  - remove `LD_LIBRARY_PATH` handling and any now-unused lib lists

## Verification

Run on at least one system (and ideally both `x86_64-linux` and `aarch64-linux`):

1) Flake evaluation:

- `nix flake show`

2) Shell env sanity:

- `nix develop .#idf_v5_5_3 --command sh -lc 'printf "%s\n" "$NIX_LD"'`
- `nix develop .#idf_v5_5_3 --command sh -lc 'test -z "${LD_LIBRARY_PATH-}"'`
- `nix develop .#idf_v5_5_3 --command sh -lc 'printf "%s\n" "$NIX_LD_LIBRARY_PATH" | head -c 1 >/dev/null'`

3) ESP-IDF activation path:

- With `IDF_PATH` set to a real checkout:
  - `IDF_PATH=~/... nix develop .#idf_v5_5_3 --command idf.py --version`

- First-time setup path:
  - `nix develop .#idf_v5_5_3`
  - `idf-sync`
  - `. "$IDF_PATH/export.sh"`
  - `idf.py --version`

4) Foreign tool execution (nix-ld):

- Ensure the system has an interpreter shim at `/lib64/ld-linux-*.so.*`.
- In the shell, run a known foreign binary (e.g., IDF-downloaded `openocd`) and confirm it starts without `LD_LIBRARY_PATH`.

5) Matter host build sanity (in a connectedhomeip checkout):

- `nix develop <this-flake>#idf_v5_5_3`
- `./scripts/bootstrap.sh`
- `source ./scripts/activate.sh`
- Run one known GN/Ninja build for your target.

## Rollback plan

- If removing `LD_LIBRARY_PATH` causes critical breakage, reintroduce it only as a last resort; prefer adding missing packages to `runtimeLibs` and keeping `NIX_LD_LIBRARY_PATH` as the single library path mechanism.
