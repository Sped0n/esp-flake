# Goal

Make the repo's `flake.nix` devShell(s):

- Work for ESP-IDF worktrees *and* Matter (connectedhomeip) host builds.
- Export `NIX_LD` (from `.../nix-support/dynamic-linker`) and a minimal-ish `NIX_LD_LIBRARY_PATH` for foreign/CIPD tools.
- Export `LD_LIBRARY_PATH` for Python `ctypes` / `pgi` style loads (this is separate from `NIX_LD_LIBRARY_PATH`).

# Current State (repo)

- Only Nix file is `flake.nix`.
- Dev shells already:
  - manage ESP-IDF worktrees and tools per tag
  - support multiple Linux systems (`x86_64-linux`, `aarch64-linux`)
  - export `NIX_LD` / `NIX_LD_LIBRARY_PATH` for ESP-IDF downloaded tools
  - export a minimal `LD_LIBRARY_PATH` for Python GI/ctypes

# Key Constraint / Risk

Transparent execution of foreign ELF binaries requires that the interpreter path recorded in the binary (`PT_INTERP`, typically `/lib64/ld-linux-*.so.*`) exists.

`NIX_LD` / `NIX_LD_LIBRARY_PATH` are consumed by the `nix-ld` *interpreter shim*, but exporting them alone cannot change `PT_INTERP`. So:

- If you completely remove the system-provided interpreter path (i.e., no `/lib64/ld-linux-*.so.*`), foreign binaries will not start, regardless of `NIX_LD_LIBRARY_PATH`.
- The minimal “system-wide” requirement for *transparent* exec is only the interpreter shim path (usually provided by `programs.nix-ld.enable` or an equivalent tmpfiles symlink). The huge library list does not need to be system-wide.

# Recommended Implementation

## A) Matter build prerequisites

- Keep existing Matter build deps in `buildPkgs`.
- Add a few small missing common prerequisites used by connectedhomeip scripts/builds:
  - `zip` (bootstrap scripts commonly need it)
  - `gperf` (often required by GN/Ninja-based builds)
- Keep Python as a “bootstrap Python” and ensure it includes `pip`, `setuptools`, `wheel`, `virtualenv`.

## B) One shared runtime lib list (but keep glibc out of `LD_LIBRARY_PATH`)

Matter + ESP-IDF tooling needs two different mechanisms:

- `NIX_LD_LIBRARY_PATH`: for running foreign/CIPD tools via `nix-ld` (must include `glibc`).
- `LD_LIBRARY_PATH`: for Python `ctypes`/GI dlopen (should *avoid* `glibc` to prevent `/bin/sh` glibc skew issues).

Implement this with a shared base list plus a small per-variable tweak:

- `runtimeLibs = [ stdenv.cc.cc zlib openssl libffi glib gobject-introspection dbus avahi libevent cairo readline util-linux systemd libusb1 ncurses5 ncurses ]`
- `nixLdRuntimeLibs = [ glibc ] ++ runtimeLibs`
- `ldRuntimeLibs = runtimeLibs` (no glibc)

Then:

- Set `NIX_LD = lib.fileContents "${pkgs.stdenv.cc}/nix-support/dynamic-linker"`.
- Set `NIX_LD_LIBRARY_PATH = lib.makeLibraryPath nixLdRuntimeLibs`.
- Set `LD_LIBRARY_PATH = "${lib.makeLibraryPath ldRuntimeLibs}:''${LD_LIBRARY_PATH-}"`.

Optionally support clean extension without bloating defaults:

- `NIX_LD_LIBRARY_PATH_EXTRA` appended if set.
- `LD_LIBRARY_PATH_EXTRA` appended if set.

## C) Keep “system-wide nix-ld” minimal (interpreter only)

To disable the bloated system-wide library list but keep transparent execution, use one of:

1) Keep `programs.nix-ld.enable = true;` but set its `libraries` to empty/minimal, and let the flake shell provide `NIX_LD_LIBRARY_PATH`.
2) Disable the module but create only the interpreter symlink via `systemd.tmpfiles.rules` (still requires `pkgs.nix-ld` in the system closure).

This repo change focuses on per-shell `NIX_LD` / `NIX_LD_LIBRARY_PATH` (and `LD_LIBRARY_PATH`). It intentionally does not try to mutate binaries (no `patchelf`) and does not add wrappers.

# Verification

- Enter shell: `nix develop` (x86_64 first).
- Check env vars:
  - `echo $NIX_LD` is a `/nix/store/.../ld-linux-...` path.
  - `echo $NIX_LD_LIBRARY_PATH` is not bloated.
  - `echo $LD_LIBRARY_PATH` contains the runtime libs base.
- ESP-IDF sanity:
  - `idf.py --version`
  - `xtensa-esp-elf-gcc --version`
  - `openocd --version`
- Matter sanity (in a connectedhomeip checkout):
  - `./scripts/bootstrap.sh` then `source ./scripts/activate.sh`
  - Build a known Linux target (e.g., `gn gen out/debug` / `ninja -C out/debug` depending on your workflow)
- Missing libs loop:
  - If a foreign tool fails with missing `.so`, use `patchelf --print-needed <bin>` to get the missing SONAME, add the providing Nix package to `runtimeLibs`, and re-enter `nix develop`.
